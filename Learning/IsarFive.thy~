theory IsarFive imports Main HOL.Fun
begin

lemma "\<not> surj (f :: 'a \<Rightarrow> 'a set)"
proof
  assume "surj f"
  hence "\<exists>a. {x. x \<notin> f x} = f a" by (auto simp add: surj_def)
  thus "False" by blast
qed

lemma
  fixes f :: "'a \<Rightarrow> 'a set"
  assumes s: "surj f"
  shows "False"
proof -
  from s have "\<exists>a. {x. x \<notin> f x} = f a" by (auto simp add: surj_def)
  thus "False" by blast
qed

(*
  T x T ---- f ----> Y
    ^                |
    |                |
 Diagonal          alpha  
    |                |
    |                v
    T   ---- g ----> Y
*)
theorem "Generalized_Cantor":
  fixes alpha :: "'b \<Rightarrow> 'b" and f :: "'a \<Rightarrow> 'a \<Rightarrow> 'b"
  assumes surjectivity: "surj f"
  and no_fixed_point: "\<forall>y. alpha y \<noteq> y"
  shows "False"
proof -
  from surjectivity have "\<forall>h :: 'a \<Rightarrow> 'b. \<exists>t. h = f t" by (auto simp add: surj_def)
  hence "\<exists>t. (alpha \<circ> (\<lambda>t'. f t' t')) = f t" by simp
  then obtain t0 where "(alpha \<circ> (\<lambda>t'. f t' t')) = f t0" ..
  hence "(alpha \<circ> (\<lambda>t'. f t' t')) t0 = f t0 t0" by (rule arg_cong)
  hence "alpha (f t0 t0) = f t0 t0" by simp
  thus "False" using no_fixed_point by simp
qed


(*
  S x T ---- f ----> Y
    ^                |
    |                |
(beta, Id)         alpha             S ---- beta_comp ----> T              beta \<circ> beta_comp = Id  
    |                |
    |                v
    T   ---- g ----> Y
*)
theorem "Abstracted_Cantor":
  fixes f :: "'b \<Rightarrow> 'a \<Rightarrow> 'c" and alpha :: "'c \<Rightarrow> 'c" and beta :: "'a \<Rightarrow> 'b" and beta_comp :: "'b \<Rightarrow> 'a"
  assumes surjectivity: "surj f"
  and no_fixed_point: "\<forall>y. alpha y \<noteq> y"
  and right_inverse: "\<forall>s. beta (beta_comp s) = s"
  shows "False"
proof -
  from surjectivity have "\<forall>h :: 'a \<Rightarrow> 'c. \<exists>t. h = f t" by auto
  hence "\<exists>t. (alpha \<circ> (\<lambda>t'. f (beta t') t')) = f t" by simp
  then obtain t0 where "(alpha \<circ> (\<lambda>t'. f (beta t') t')) = f t0" ..
  hence "(alpha \<circ> (\<lambda>t'. f (beta t') t')) (beta_comp t0) = f t0 (beta_comp t0)" by (rule arg_cong)
  hence "alpha (f (beta (beta_comp t0)) (beta_comp t0)) = f t0 (beta_comp t0)" by simp
  hence "alpha (f t0 (beta_comp t0)) = f t0 (beta_comp t0)" using right_inverse by simp
  thus "False" using no_fixed_point by simp
qed

end
